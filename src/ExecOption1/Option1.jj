PARSER_BEGIN(StatsAttributs)
import java.util.HashMap;
import java.io.*;

enum Keys { PRIVATE, PROTECTED, PUBLIC, CLASSES }

public class StatsAttributs {
	public static void main(String[] args) {
		try {
		  InputStream inputStream = new FileInputStream(new File("parsing.txt"));
		  new StatsAttributs(inputStream).Input();
		  System.out.println("Parser executed with success.");
		} catch (Throwable e) {
			System.out.println("Syntax check failed : " + e.getMessage());
		}
	}
}

class Stats {
  	static int privates = 0, publics = 0, protecteds = 0;
  	static private Integer repeatLong = 15, repeatDefault = 8;
  	
	static HashMap<Keys, Integer> cache = new HashMap<Keys, Integer>();
	static HashMap<Keys, Integer> buffer = new HashMap<Keys, Integer>();

	static void updateBuffer() {
		buffer.putAll(cache);
	}

	static void output() {
	  	int total = publics + privates + protecteds;

		lineOutput(repeatLong);
	  	System.out.println("Total d'attributs : " + total);
	  	lineOutput(repeatDefault);
	  	System.out.println("\n Nombre d'attribut public  : " + publics);
	  	pourcentage("Pourcentage d'attributs public : ", total, publics);

	  	lineOutput(repeatDefault);
		System.out.println("Nombre d'attribut private  : " + privates);
	  	pourcentage("Pourcentage d'attributs private : ", total, privates);

		lineOutput(repeatDefault);
	  	System.out.println("Nombre d'attribut protected  : " + protecteds);
	  	pourcentage("Pourcentage d'attributs protected : ", total, protecteds);
	  	lineOutput(repeatLong);
	}

	private static void pourcentage(String message, int total, int attributes) {
		if (total > 0) { System.out.println(message + String.format("%.2f", (float) attributes/total * 100) + "%"); }
		else { System.out.println(message + "0%"); }
	}

	private static void lineOutput(Integer repeat) {
		System.out.println(new String(new char[repeat]).replace("\0", "-"));
	}
}
PARSER_END(StatsAttributs)

SKIP:  { " " | "\t" | "\n" | "\r" }
TOKEN:
{
  <PRIVATE: "private">
  | <PROTECTED: "protected">
  | <PUBLIC: "public">
  | <STATIC: "static">
  | <CLASS: "class">
  | <NEW: "new">
}

TOKEN:
{
  <LBRACE: "{"> | <RBRACE: "}">
  | <LPARENTHESIS: "("> | <RPARENTHESIS: ")">
  | <EQUAL: "=">
  | <DOT: ".">
  | <SEMICOLON: ";">
  | <UPPERCAMEL: (["A"-"Z"])+(["a"-"z","A"-"Z", "0"-"9", "_"])*>
  | <LOWERCAMEL: (["a"-"z"])+(["a"-"z","A"-"Z", "0"-"9", "_"])*>
}

TOKEN:
{
  <NUMBER: <INTEGER> | <REEL>>
  | <INTEGER: ("-")? (["0"-"9"])+>
  | <REEL: ("-")? <INTEGER> (<DOT> <INTEGER>)?>
}

void Input() : {} { MatchedClass() <EOF> { Stats.output(); }}

void MatchedClass() : {}
{
  <CLASS> <UPPERCAMEL> [MatchedBraces()] [MatchedClass()]
}

void MatchedBraces() : {}
{
 	<LBRACE> MatchedAttributsOrMethod() [MatchedBraces()] <RBRACE>
}

void MatchedAttributsOrMethod(): { Token token; }
{
  (token = Prefixer() (MatchedAttribut(token)| Method())+)*
}

void MatchedAttribut(Token token) : { }
{
  Attribut()
  {
	if (token == null || token.image == "public") { ++Stats.publics; }
	else if (token.image == "private") { ++Stats.privates; }
	else if (token.image == "protected") { ++Stats.protecteds; }
	else { throw new ParseException("Spécificateur d'accès invalide."); }
  }
}

Token AccessSpecifier(): {Token token = null;} { (token = <PUBLIC> | token = <PRIVATE> | token = <PROTECTED> | token = <STATIC>)* { return token; }}
Token Prefixer(): { Token token = null; } { token = AccessSpecifier() Type() <LOWERCAMEL> { return token; }}

void Attribut(): {} { <EQUAL> Value() <SEMICOLON> }

void Method(): {} { Parenthesis() <LBRACE> <RBRACE>} // Inside method not handled

void Value(): {} { NewObject() | <LOWERCAMEL> | Number() }

void Type(): { } { <UPPERCAMEL> | <LOWERCAMEL> }

void NewObject(): {} { <NEW> <UPPERCAMEL> Parenthesis() }

void Parenthesis(): {} { <LPARENTHESIS> [Params()] <RPARENTHESIS> }

void Params(): {} { Value() ("," Value())* }


void Number(): {}
{
  <NUMBER>
  {
     Token nextToken = getToken(1);
     if (nextToken.image.equals(".")) {
		throw new ParseException("A number can only have one [.]. Expected value : " + getToken(0).image);
     }
  }
}