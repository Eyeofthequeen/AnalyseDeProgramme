/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  STATIC = false;
  DEBUG_PARSER = false;
}

//TODO: Association: method parameters/return type?
//TODO: Langage does not support keyword "new" (inside functions)

PARSER_BEGIN(Option3)

import java.nio.file.*;
import java.util.*;

public class Option3 {
    public static void main(String[] args) {
    		try {
                String file = Files.readString(Paths.get(args[0]));
    		    new Option3(new java.io.StringReader(file)).Input();
    		} catch (Throwable e) {
    			System.out.println("Syntax check failed: " + e.getMessage());
    		}
    	}
}

class Link {
    public String from;
    public String to;
    public LinkType type;

    public Link() {}
    public Link(String from, String to, LinkType type) {
        this.from = from;
        this.to = to;
        this.type = type;
    }

    public String toString() {
        return from + ((type == LinkType.INHERITANCE) ? "---|>" : "-----") + to;
    }
}

class ClassLink {
    String name = "";
    private List<Link> links = new ArrayList<>();

    public void add(Link link) {
        links.add(link);
    }

    public void addAssociation(String type) {
        // check if the first letter is a capital letter
        if (name.charAt(0) != name.toLowerCase().charAt(0)) {
            add(new Link(name, type, LinkType.ASSOCIATION));
        }
    }

    public String toString() {
        StringBuilder sb = new StringBuilder();
        if (links.size() > 0)
            for (Link link : links)
                sb.append(link).append("\n");

        return sb.toString();
    }
}

class Links {
    static List<ClassLink> classLinks = new ArrayList<>();
    static Set<String> names = new HashSet<>();

    static void print() {
        for(String name: names)
            System.out.println("class " + name);

        for(ClassLink classLink: classLinks)
            System.out.println(classLink);
    }
}

enum LinkType {
    INHERITANCE,
    ASSOCIATION
}

PARSER_END(Option3)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

MORE :
{
	"//" : IN_SINGLE_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT>
MORE :
{
  < ~[] >
}

SPECIAL_TOKEN : {
    <EOL: "\n" | "\r">
}

TOKEN: { <LBRACE: "{"> | <RBRACE: "}"> | <PRIVATE: "private"> | <PROTECTED: "protected"> | <PUBLIC: "public"> | <STATIC: "static"> | <ABSTRACT: "abstract"> | <CLASS: "class"> | <INTERFACE: "interface">
        | <EXTENDS: "extends"> | <IMPLEMENTS: "implements"> | <COMMA: ","> | <L_PARENTHESIS: "("> | <R_PARENTHESIS: ")"> | <SEMI_COLON: ";">  | <DOT : "."> }

TOKEN : /* OPERATEURS */
{
  < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < MODULO : "%" >
| < ASSIGN : "=" >
| < EQUAL : "==" >
| < NOT_EQUAL : "<>" >
| < GREATER : ">" >
| < GREATER_OR_EQUAL : ">=" >
| < LOWER : "<" >
| < LOWER_OR_EQUAL : "<=" >
| < AND : "&&" >
| < OR : "||" >
| < NOT : "!" >
| < PREFIX_INCREMENT : "++" >
| < PREFIX_DECREMENT : "--" >
}

TOKEN : /* MOTS CLï·¿S */
{
  < IF : "if" >
| < ELSE : "else" >
| < WHILE : "while" >
| < TRUE: "TRUE" >
| < FALSE : "FALSE" >
| < RETURN : "return" >
| < NEW : "new" >
}

TOKEN : /* TYPES */
{
< VOID : "void" >
}

TOKEN :	/* LITTERAUX */
{
  < #DIGIT: ["0"-"9"] >
| < #LETTER : ["A"-"Z", "a" - "z"] >
| < INTEGER : ("-")? ( < DIGIT > )+ >
| < DECIMAL :
		("-")? (< DIGIT >)+ "." (< DIGIT >)*
	|  	("-")? (< DIGIT >)* "." (< DIGIT >)+
	>
| < IDENTIFIER : < LETTER > (< LETTER > | < DIGIT >)* >
}

void Input() : {}
{
    [Class()]
    {
        Links.print();
    }
}

void Class() : {String name = null; ClassLink classLink = new ClassLink();}
{
    [Visibility()]
    (([<ABSTRACT>] <CLASS>) | <INTERFACE>)
    // needed to know which class variables counts as an association
    classLink.name=ClassName()
    [Extension(classLink)]
    [Implementation(classLink)]
    MatchedBraces(classLink)
    {
        Links.names.add(classLink.name);
        Links.classLinks.add(classLink);
    }
    [Class()]
}

String ClassName() : {Token token;}
{
    token = <IDENTIFIER>
    {return token.image;}
}

void MatchedBraces(ClassLink classLink) : {}
{
   <LBRACE> (LOOKAHEAD([Visibility()] ( <IDENTIFIER> | < VOID > ) < IDENTIFIER > "(") function() | Attribute(classLink) )* <RBRACE>
}

void Visibility() : {}
{
    <PRIVATE> | <PROTECTED> | <PUBLIC>
}

void Extension(ClassLink classLink) : {Token to;}
{
    <EXTENDS> to=<IDENTIFIER>
    {
        classLink.add(new Link(classLink.name, to.image, LinkType.INHERITANCE));
    }
}

void Implementation(ClassLink classLink) : {Token token;}
{
    <IMPLEMENTS> token=<IDENTIFIER> (MultipleImplementations(classLink))*
    {
        classLink.add(new Link(classLink.name, token.image, LinkType.INHERITANCE));;
    }
}

void MultipleImplementations(ClassLink classLink) : {Token token;}
{
    <COMMA> token=<IDENTIFIER>
    {
        classLink.add(new Link(classLink.name, token.image, LinkType.INHERITANCE));
    }
}

void Attribute(ClassLink classLink) : {Token type;}
{
    [Visibility()] type=<IDENTIFIER> <IDENTIFIER> [<ASSIGN> ( (<NEW> <IDENTIFIER> "(" (parameter_declaration() ("," parameter_declaration())*)? ")") | logical_expression()) ] <SEMI_COLON>
    {classLink.addAssociation(type.image);}
}

// -----------

void function() : {}
{
    [Visibility()]
    ( type() | < VOID > )
    < IDENTIFIER > "(" (parameter_declaration() ("," parameter_declaration())*)? ")"
    (("{" function_body() "}") | ";")
}

void parameter_declaration() : {}
{
    type() < IDENTIFIER >
}

// FIXME: Bug where JavaCC mixes variable_declaration() and statement() when calling function alone
//  (ex: calling builder.toString() without assigning it or returning it)
void function_body() : {}
{
    ( variable_declaration() ";" )*
    ( statement() )*
    ( return_statement() )?
}

void statement() : {}
{
    ( LOOKAHEAD(2)
    assignment() | function_call() ) ";"
    | conditional_statement()
    | while_loop()
}

void variable_declaration() : {}
{
    type() assignment() ("," assignment() )*
}

void litteral_value() : {}
{
    < INTEGER >
    | < DECIMAL >
    | boolean_value()
}

void boolean_value() : {}
{
    < TRUE > | < FALSE >
}

String type() : {Token type;}
{
    type=<IDENTIFIER>
    {return type.image;}
}

void conditional_statement() : {}
{
    < IF > "(" logical_expression()	")" "{" ( statement() )*
    ( LOOKAHEAD(2) "}" < ELSE > "{" ( statement() )* )? "}"
}

void logical_expression() : {}
{
    comparison_expression() ( logical_connector() comparison_expression() )*
}

void comparison_expression() : {}
{
    arithmetic_expression_priority_low() ( comparison_operator() arithmetic_expression_priority_low() )*
}

void arithmetic_expression_priority_low() : {}
{
    arithmetic_expression() ( arithmetic_operation_piority_low() arithmetic_expression() )*
}

void arithmetic_expression() : {}
{
    unary_expression() ( arithmetic_operation() unary_expression() )*
}

void unary_expression() : {}
{
    ( unary_operator() )? term()
}

void term() : {}
{
    value() | "(" logical_expression() ")"
}

void unary_operator() : {}
{
    < PREFIX_INCREMENT >
    | < PREFIX_DECREMENT >
    | < NOT >
}

void value() : {}
{
    LOOKAHEAD(2) function_call()
    | < IDENTIFIER >
    | litteral_value()
}

void arithmetic_operation() : {}
{
    < MULTIPLY > | < DIVIDE > | < MODULO >
}

void arithmetic_operation_piority_low() : {}
{
    < PLUS > | < MINUS >
}

void comparison_operator() : {}
{
    < EQUAL > | < NOT_EQUAL > | < GREATER > | < GREATER_OR_EQUAL > | < LOWER > | < LOWER_OR_EQUAL >
}

void logical_connector() : {}
{
    < AND > | < OR >
}

void function_call() : {}
{
    [<IDENTIFIER> <DOT>] < IDENTIFIER > "(" (logical_expression() ("," logical_expression())*)? ")"
}

String assignment() : {Token name;}
{
    name=<IDENTIFIER> < ASSIGN > logical_expression()
    {return name.image;}
}

void while_loop() : {}
{
    < WHILE > "(" logical_expression() ")" "{" (statement())* "}"
}

void return_statement() : {}
{
    < RETURN > logical_expression() ";"
}