options
{
  static = false;
  debug_parser = false;
}

PARSER_BEGIN(Visibility)
import java.util.*;
import java.io.*;

enum Keys { PRIVATE, PROTECTED, PUBLIC }

public class Visibility {
    public static void main(String[] args) {
        try {
          	InputStream inputStream = new FileInputStream(new File("parsing.txt"));
         	new Visibility(inputStream).Input();
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            System.out.println("Syntax check failed: " + e.getMessage());
        }
    }
}

class OutputUtils {
	static void pourcentage(String message, int total, int attributes) {
		if (total > 0) { System.out.println(message + String.format("%.2f", (float) attributes/total * 100) + "%"); }
		else { System.out.println(message + "0%"); }
	}

	static void lineOutput(Integer repeat) {
		System.out.println(new String(new char[repeat]).replace("\0", "-"));
	}
}

class TypeAttributeCounter {
  	private static boolean isReferencedAttribute;
  	private static Integer nbSimpleAttributes, nbReferencedAttributes;
  	static Map<String, Integer> nbSimpleAttributesByClass = new HashMap<String, Integer>();
	static Map<String, Integer> nbReferencedAttributesByClass = new HashMap<String, Integer>();

	TypeAttributeCounter() {
	  	isReferencedAttribute = false;
		nbSimpleAttributes =  0;
		nbReferencedAttributes = 0;
		nbSimpleAttributesByClass = new HashMap<String, Integer>();
		nbReferencedAttributesByClass = new HashMap<String, Integer>();
	}

	static void incrementSimpleAttributes() {
		++nbSimpleAttributes;
	}

	static void incrementReferencedAttributes() {
		++nbReferencedAttributes;
		isReferencedAttribute = true;
	}

	static int getTotalForClass(String name) {
		return nbSimpleAttributesByClass.get(name) + nbReferencedAttributesByClass.get(name);
	}

	static boolean getIsReferencedAttribute() { return isReferencedAttribute; }

	static void reset() { nbSimpleAttributes = nbReferencedAttributes = 0; }

	static void compile(String currentClassName) {
		nbSimpleAttributesByClass.put(currentClassName, nbSimpleAttributes);
		nbReferencedAttributesByClass.put(currentClassName, nbReferencedAttributes);
		reset();
	}

	static void resetIsReferenced() { isReferencedAttribute = false; }

	static void output(String name) {
	  	Integer lineWidth = 15;
	  	Integer total = getTotalForClass(name);
	  	String pourcentLine = "Pourcentage d'attribut";

		System.out.println("\nNombre d'attribut total : " + total);
		OutputUtils.lineOutput(lineWidth);

		System.out.println("Nombre d'attribut de type simple : " + nbSimpleAttributesByClass.get(name));
		OutputUtils.pourcentage(pourcentLine + " de type simple : ", total, nbSimpleAttributesByClass.get(name));
		OutputUtils.lineOutput(lineWidth);

		System.out.println("Nombre d'attribut de référence : " + nbReferencedAttributesByClass.get(name));
		OutputUtils.pourcentage(pourcentLine + " de référence : ", total, nbReferencedAttributesByClass.get(name));
		OutputUtils.lineOutput(lineWidth);
	}
}

class SpecifierAttributeCounter {
	static Integer privates, publics, protecteds;
	static Map<String, Map<Keys, Integer>> nbAttributesBySpecifierByClass = new HashMap<String, Map<Keys, Integer>>();

	SpecifierAttributeCounter() {
		privates = 0;
		publics = 0;
		protecteds = 0;
	}

	static void increment(Keys key) {
		switch (key) {
			case PRIVATE: ++privates; break;
			case PUBLIC: ++publics; break;
			case PROTECTED: ++protecteds; break;
		}
	}

	static void reset() { privates = publics = protecteds = 0; }

	static void compile(String name) {
	  	nbAttributesBySpecifierByClass.put(name, new HashMap<Keys, Integer>());
		nbAttributesBySpecifierByClass.get(name).put(Keys.PUBLIC, publics);
		nbAttributesBySpecifierByClass.get(name).put(Keys.PROTECTED, protecteds);
		nbAttributesBySpecifierByClass.get(name).put(Keys.PRIVATE, privates);
		reset();
	}

	static void output(String name, Integer total) {
	  	Integer repeatLong = 15, repeatDefault = 8;
	  	String pourcentLine = "Pourcentage d'attribut";
	  
		System.out.println("Nombre d'attribut public : " + nbAttributesBySpecifierByClass.get(name).get(Keys.PUBLIC));
		OutputUtils.pourcentage(pourcentLine + "  public : ", total, nbAttributesBySpecifierByClass.get(name).get(Keys.PUBLIC));
		OutputUtils.lineOutput(repeatDefault);

		System.out.println("Nombre d'attribut private : " + nbAttributesBySpecifierByClass.get(name).get(Keys.PRIVATE));
		OutputUtils.pourcentage(pourcentLine + "  private : ", total, nbAttributesBySpecifierByClass.get(name).get(Keys.PRIVATE));
		OutputUtils.lineOutput(repeatDefault);

		System.out.println("Nombre d'attribut protected : " + nbAttributesBySpecifierByClass.get(name).get(Keys.PROTECTED));
		OutputUtils.pourcentage(pourcentLine + "  protected : ", total, nbAttributesBySpecifierByClass.get(name).get(Keys.PROTECTED));
		OutputUtils.lineOutput(repeatLong);
	}
}

class Stats {
	static TypeAttributeCounter typeAttributeCounter = new TypeAttributeCounter();
	static SpecifierAttributeCounter specifierAttributeCounter = new SpecifierAttributeCounter();
  	
	static ArrayList<String> associatedWith = new ArrayList<String>();

	static ArrayList<String> allDeclaredClasses = new ArrayList<String>();

	static Map<String, ArrayList<String>> associationsByClass = new HashMap<String, ArrayList<String>>();
	static Map<String, String> specifiersByClass = new HashMap<String, String>();

	static void compileClasses(String currentClassName, Token specifier) {
	  	String spec = (specifier == null) ? "public" : specifier.image;
	  	allDeclaredClasses.add(currentClassName);

		associationsByClass.put(currentClassName, associatedWith);
		associatedWith = new ArrayList<String>();

		specifiersByClass.put(currentClassName, spec);

		typeAttributeCounter.compile(currentClassName);
		specifierAttributeCounter.compile(currentClassName);
	}

	static void output() {
	  	Integer repeatLong = 15, repeatDefault = 8;

		for (Map.Entry<String, String> entry : specifiersByClass.entrySet()) {
			String name = entry.getKey();
			String specifier = entry.getValue();
			ArrayList<String> associations = associationsByClass.get(name);
			String pourcentLine = "Pourcentage d'attribut";

			System.out.println("\n");
			OutputUtils.lineOutput(repeatLong);
			System.out.println("Nom de la classe : " + name);
			OutputUtils.lineOutput(repeatDefault);
			System.out.println("Spécificateur d'accès : " + specifier);
			System.out.println("Nombre d'associations : " + associations.size());
			System.out.println("Associations : " + associations);

			typeAttributeCounter.output(name);
			specifierAttributeCounter.output(name, typeAttributeCounter.getTotalForClass(name));
		}
	}
}
PARSER_END(Visibility)

SKIP:  { " " | "\t" | "\n" | "\r" }
TOKEN:
{
  <PRIVATE: "private">
  | <PROTECTED: "protected">
  | <PUBLIC: "public">
  | <STATIC: "static">
  | <CLASS: "class">
  | <NEW: "new">
}

TOKEN :
{
  < INT : "int" >
| < DOUBLE : "double" >
| < BOOLEAN : "bool" >
| < VOID : "void" >
| < FLOAT: "float">
}

TOKEN:
{
  <LBRACE: "{"> | <RBRACE: "}">
  | <LPARENTHESIS: "("> | <RPARENTHESIS: ")">
  | <EQUAL: "=">
  | <DOT: ".">
  | <SEMICOLON: ";">
  | <UPPERCAMEL: (["A"-"Z"])+(["a"-"z","A"-"Z", "0"-"9", "_"])*>
  | <LOWERCAMEL: (["a"-"z"])+(["a"-"z","A"-"Z", "0"-"9", "_"])*>
  | <STRING: "\"" (<UPPERCAMEL> | <LOWERCAMEL>)? "\"">
}

TOKEN:
{
  <NUMBER: <INTEGER> | <REEL>>
  | <INTEGER: ("-")? (["0"-"9"])+>
  | <REEL: ("-")? <INTEGER> (<DOT> <INTEGER>)?>
}


void Input() : {} { MatchedClass() <EOF> { Stats.output(); }}

void MatchedClass() : { Token name, specifier; }
{
  (specifier = AccessSpecifier()) <CLASS> (name = <UPPERCAMEL>) [MatchedBraces(name.image, specifier)] [MatchedClass()]
}

void MatchedBraces(String name, Token specifier) : {}
{
	<LBRACE> MatchedAttributsOrMethod() <RBRACE>

	{ Stats.compileClasses(name, specifier); }
}

void MatchedAttributsOrMethod() : { Token token; } { (token=Prefixer() (MatchedAttribut(token)| Method())+)* }

void MatchedAttribut(Token token) : {}
{
  Attribut()
  {
	if (token == null || token.image == "public") { Stats.specifierAttributeCounter.increment(Keys.PUBLIC); }
	else if (token.image == "private") { Stats.specifierAttributeCounter.increment(Keys.PRIVATE); }
	else if (token.image == "protected") { Stats.specifierAttributeCounter.increment(Keys.PROTECTED); }
	else { throw new ParseException("Spécificateur d'accès invalide."); }
  }
}

Token AccessSpecifier(): {Token token = null;} { (token = <PUBLIC> | token = <PRIVATE> | token = <PROTECTED> | token = <STATIC>)* { return token; }}
Token Prefixer(): { Token specifier = null; } { specifier = AccessSpecifier() Type() <LOWERCAMEL> { return specifier; }}

void Method(): {} { DeclarationParams() <LBRACE> <RBRACE>}

void Params(): {} { <LPARENTHESIS> [Param() ("," Param())*] <RPARENTHESIS> }
void DeclarationParams() : {} { <LPARENTHESIS> [Type() <LOWERCAMEL> ("," Type() <LOWERCAMEL>)*] <RPARENTHESIS> }
void Param(): { } { Value(false) }

void Type(): { Token token = null; }
{
  <INT> | <DOUBLE> | <VOID> | <BOOLEAN> | <FLOAT> | token = <UPPERCAMEL>
  {
  	if (token != null) {
		Stats.associatedWith.add(token.image);
		Stats.typeAttributeCounter.incrementReferencedAttributes();
  	}
  }
}

void Attribut(): {} { <EQUAL> Value(true) <SEMICOLON> }
void Value(boolean isAttribute): { boolean isSimpleValue = false; }
{
  (NewObject() | <STRING> | isSimpleValue = IsSimpleValue())
  {
    if(isSimpleValue && isAttribute && !Stats.typeAttributeCounter.getIsReferencedAttribute()) {
      Stats.typeAttributeCounter.incrementSimpleAttributes();
  	}
  	Stats.typeAttributeCounter.resetIsReferenced();
  }
}
boolean IsSimpleValue(): { } { <LOWERCAMEL> | Number() { return true; }}

void NewObject(): { Token name; } { <NEW> name = <UPPERCAMEL> Params() }

void Number(): {}
{
  <NUMBER>
  {
     Token nextToken = getToken(1);
     if (nextToken.image.equals(".")) {
		throw new ParseException("A number can only have one [.]. Expected value : " + getToken(0).image);
     }
  }
}