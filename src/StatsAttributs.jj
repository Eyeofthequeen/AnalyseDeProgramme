PARSER_BEGIN(StatsAttributs)

import java.util.HashMap;

enum Keys { PRIVATE, PROTECTED, PUBLIC, CLASSES }

public class StatsAttributs {
	public static void main(String[] args) {
		try {
		  new StatsAttributs(new java.io.StringReader(args[0])).Input();
		  System.out.println("Parser executed with success.");
		} catch (Throwable e) {
			System.out.println("Syntax check failed : " + e.getMessage());
		}
	}
}
PARSER_END(StatsAttributs)

SKIP:  { " " | "\t" | "\n" | "\r" }
TOKEN:
{
  <PRIVATE: "private">
  | <PROTECTED: "protected">
  | <PUBLIC: "public">
  | <STATIC: "static">
  | <CLASS: "class">
  | <NEW: "new">
}

// <BASIC: ["a"-"z","A"-"Z","_"] ( ["a"-"z","A"-"Z","_","-","0"-"9"] )* >

TOKEN:
{
  <LBRACE: "{"> | <RBRACE: "}">
  | <LPARENTHESIS: "("> | <RPARENTHESIS: ")">
  | <EQUAL: "=">
  | <DOT: ".">
  | <SEMICOLON: ";">
  | <UPPERCAMEL: (["A"-"Z"])+(["a"-"z","A"-"Z", "0"-"9", "_"])*>
  | <LOWERCAMEL: (["a"-"z"])+(["a"-"z","A"-"Z", "0"-"9", "_"])*>
}

TOKEN:
{
  <NUMBER: <INTEGER> | <REEL>>
  | <INTEGER: (["0"-"9"])+>
  | <REEL: <INTEGER> (<DOT> <INTEGER>)?>
}

void Input() : {int count=0; HashMap<Keys, Integer> attributs=new HashMap<Keys, Integer>(); }
{
  attributs=MatchedClass() <EOF>
  {
    String pourcentage = " % ";
    String totalOf = "\t Avec un total de : ";
	int total = attributs.get(Keys.PROTECTED) + attributs.get(Keys.PUBLIC) + attributs.get(Keys.PRIVATE);

	System.out.println("Total d'attributs : " + total);
	System.out.println("Pourcentage d'attributs public :  " + Pourcentage(total, attributs.get(Keys.PUBLIC)) + pourcentage + totalOf + attributs.get(Keys.PUBLIC));
	System.out.println("Pourcentage d'attributs protected : " + Pourcentage(total, attributs.get(Keys.PROTECTED)) + pourcentage + totalOf + attributs.get(Keys.PROTECTED));
	System.out.println("Pourcentage d'attributs private : " + Pourcentage(total, attributs.get(Keys.PRIVATE)) + pourcentage + totalOf + attributs.get(Keys.PRIVATE));
  }
}

String Pourcentage(int total, int attributes): { } {
  {  	  	
	if (total > 0) {
		return String.format("%.2f", (float) attributes/total * 100);
	}
	return "0";
  }
}

HashMap<Keys, Integer> MatchedClass() : { HashMap<Keys, Integer> data=new HashMap<Keys, Integer>(), buffer=new HashMap<Keys, Integer>();}
{
  <CLASS> <UPPERCAMEL> [buffer=MatchedBraces()] [data=MatchedClass()]
  {    
    int publicAtt = data.getOrDefault(Keys.PUBLIC, 0);
	int privateAtt = data.getOrDefault(Keys.PRIVATE, 0);
	int protectedAtt = data.getOrDefault(Keys.PROTECTED, 0);
    int classes = data.getOrDefault(Keys.CLASSES, 0);
    
    data.put(Keys.CLASSES, ++classes);
    data.put(Keys.PUBLIC, publicAtt + buffer.getOrDefault(Keys.PUBLIC, 0));
    data.put(Keys.PRIVATE, privateAtt + buffer.getOrDefault(Keys.PRIVATE, 0));
    data.put(Keys.PROTECTED, protectedAtt + buffer.getOrDefault(Keys.PROTECTED, 0));

    return data;
  }
}

HashMap<Keys, Integer> MatchedBraces() : { HashMap<Keys, Integer> nestedAttributs=new HashMap<Keys, Integer>(); Token token;}
{
 	<LBRACE> nestedAttributs = MatchedAttributsOrMethod() [MatchedBraces()] <RBRACE>
 	{ return nestedAttributs; }
}

HashMap<Keys, Integer> MatchedAttributsOrMethod(): { Token token; HashMap<Keys, Integer> nestedAttributs=new HashMap<Keys, Integer>(); }
{
  (token = Prefixer() (nestedAttributs=MatchedAttribut(token, nestedAttributs)| Method())+)*
  { return nestedAttributs; }
}

HashMap<Keys, Integer> MatchedAttribut(Token token, HashMap<Keys, Integer> attributs) : { }
{
  Attribut()
  {
    int publicAtt = attributs.getOrDefault(Keys.PUBLIC, 0);
	int privateAtt = attributs.getOrDefault(Keys.PRIVATE, 0);
	int protectedAtt = attributs.getOrDefault(Keys.PROTECTED, 0);

	if (token == null || token.image == "public") { ++publicAtt; }
	else if (token.image == "private") { ++privateAtt; }
	else if (token.image == "protected") { ++protectedAtt; }
	
    attributs.put(Keys.PUBLIC, publicAtt);
    attributs.put(Keys.PRIVATE, privateAtt);
    attributs.put(Keys.PROTECTED, protectedAtt);
    
    return attributs;
  }
}

Token AccessSpecifier(): {Token token = null;} { (token = <PUBLIC> | token = <PRIVATE> | token = <PROTECTED> | token = <STATIC>)* { return token; }}
Token Prefixer(): { Token token = null; } { token = AccessSpecifier() Type() <LOWERCAMEL> { return token; }}

void Attribut(): {} { <EQUAL> Value() <SEMICOLON> }

void Method(): {} { Parenthesis() <LBRACE> <RBRACE>} // Inside method not handled

void Value(): {} { [NewObject() | <LOWERCAMEL> | Number()] }

void Type(): { } { <UPPERCAMEL> | <LOWERCAMEL> }

void NewObject(): {} { <NEW> <UPPERCAMEL> Parenthesis() }

void Parenthesis(): {} { <LPARENTHESIS> Params() <RPARENTHESIS> }

void Params(): {} { Value() ("," Value())* }


void Number(): {}
{
  <NUMBER>
  {
     Token nextToken = getToken(1);
     if (nextToken.image.equals(".")) {
		throw new ParseException("A number can only have one [.]. Expected value : " + getToken(0).image);
     }
  }
}